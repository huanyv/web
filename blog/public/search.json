[{"title":"如何用SpringSecurity自定义验证码？","path":"/2023/01/07/如何用SpringSecurity自定义验证码？/","content":"如何用SpringSecurity自定义验证码？导入依赖 这里使用Google的验证码 因为Google官方的maven坐标导入不了，使用的是镜像 12345&lt;dependency&gt;\t&lt;groupId&gt;com.github.penggle&lt;/groupId&gt;\t&lt;artifactId&gt;kaptcha&lt;/artifactId&gt;\t&lt;version&gt;2.3.2&lt;/version&gt;&lt;/dependency&gt; 设置图片验证码路径 谷歌提供了一个默认的Servletcom.google.code.kaptcha.servlet.KaptchaServlet 设置路径 12345678@Configurationpublic class ServletConfig &#123; @Bean public ServletRegistrationBean&lt;KaptchaServlet&gt; servletRegistrationBean() &#123; KaptchaServlet kaptchaServlet = new KaptchaServlet(); return new ServletRegistrationBean&lt;&gt;(kaptchaServlet,&quot;/captcha.jpg&quot;); &#125;&#125; 自定义filter 自定义一个filter来校验验证码 12345678910111213141516171819202122232425262728293031323334@Componentpublic class CheckCaptchaFilter extends OncePerRequestFilter &#123;\t// 谷歌的默认验证码session key private static final String CAPTCAH_SESSION_KEY = Constants.KAPTCHA_SESSION_KEY; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; String realRequestUrl = request.getRequestURI().substring(request.getContextPath().length()); // 不是登录请求，放行 if (!&quot;/login&quot;.equals(realRequestUrl)) &#123; filterChain.doFilter(request,response); return; &#125; // 获取默认的 captcha String sessionCaptcha = (String) request.getSession().getAttribute(CAPTCAH_SESSION_KEY); String captcha = request.getParameter(&quot;captcha&quot;); if (sessionCaptcha == null || captcha == null) &#123; response.sendRedirect(request.getContextPath() + &quot;/login.html&quot;); return; &#125; if(sessionCaptcha.equalsIgnoreCase(captcha)) &#123; // 验证码正确，清除验证码session request.getSession().removeAttribute(CAPTCAH_SESSION_KEY); filterChain.doFilter(request,response); &#125; else &#123;// throw new RuntimeException(&quot;验证码错误&quot;); response.sendRedirect(request.getContextPath() + &quot;/login.html&quot;); &#125; &#125;&#125; Filter添加 把自定义的filter添加到Security的过滤器链中 应当在身份验证过滤器之前UsernamePasswordAuthenticationFilter 12345678910111213141516@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private CheckCaptchaFilter checkCaptchaFilter; // 省略..... @Override protected void configure(HttpSecurity http) throws Exception &#123; // 省略..... http.addFilterBefore(checkCaptchaFilter, UsernamePasswordAuthenticationFilter.class); &#125;&#125;"},{"title":"前后端分离，简单JWT登录实现","path":"/2023/01/07/前后端分离，简单JWT登录实现/","content":"前后端分离，简单JWT登录实现[toc] JWT登录流程 前端vue+axios+router 后端springboot+mybatisplus 1. 用户认证处理123456789101112131415161718192021222324252627282930@Service@Transactionalpublic class AdminServiceImpl implements AdminService &#123; @Autowired private AdminMapper adminMapper; @Override public ResponseResult adminLogin(Admin loginAdmin) &#123; // 从数据库查出用户信息 LambdaQueryWrapper&lt;Admin&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(Admin::getUsername,loginAdmin.getUsername()); Admin admin = adminMapper.selectOne(queryWrapper); // 用户不存在，直接认证失败 if (admin == null) &#123; return new ResponseResult(ResponseResult.FORBIDDEN,&quot;登录失败&quot;); &#125; // 用户名与密码校验 if (admin.getUsername().equals(loginAdmin.getUsername()) &amp;&amp; admin.getPassword().equals(loginAdmin.getPassword())) &#123; // 校验成功，生成jwt返回数据 String jwt = JwtUtil.createJWT(String.valueOf(loginAdmin.getId()), 1000L * 60 * 60 * 24); Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;,jwt); return new ResponseResult(ResponseResult.OK,&quot;登录成功&quot;,map); &#125; // 密码校验失败 return new ResponseResult(ResponseResult.FORBIDDEN,&quot;登录失败&quot;); &#125;&#125; 2. 前端登录12345678910111213141516login(&#123; username: this.username, password: this.password &#125;).then(response =&gt; &#123; let data = response.data; // 登录成功 if (data.code == 200) &#123; message.success(data.msg) // 保存token到localstorage window.localStorage.setItem(&quot;token&quot;, data.data.token) // 用户信息保存 window.localStorage.setItem(&quot;username&quot;, this.username) // 跳转到主页 this.$router.push(&quot;/admin&quot;); &#125; else &#123; message.error(data.msg) &#125; &#125; ); 3. 前端请求处理 前端每次发出请求时，请求头要携带之前登录成功保存的token 这里用axios拦截器示例 12345678910111213141516171819202122232425262728const http = axios.create(&#123; baseURL: &#x27;http://localhost:8080&#x27;, // timeout: 4000&#125;)// 配置请求拦截器http.interceptors.request.use( config =&gt; &#123; config.headers = &#123; // 每次请求前带上Token token: window.localStorage.getItem(&quot;token&quot;) &#125; return config; &#125;, err =&gt; Promise.reject(err));// 配置响应拦截器，主要做登录过期的处理，后端在解析token失效时返回401http.interceptors.response.use(res =&gt; &#123; // 登录过期，跳转到登录页面 if (res.data.code == 401) &#123; message.error(res.data.msg) router.push(&quot;/admin/login&quot;) &#125; return res;&#125;, err =&gt; &#123; return Promise.reject(err)&#125;); 4. 后端请求处理 每次接收到请求，要校验token是否合法 这里用拦截器示例 1234567891011121314151617181920212223242526272829303132333435363738394041public class RequestCheckTokenInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; response.setContentType(&quot;text/html; charset=utf-8&quot;); // OPTIONS为预检请求，直接放行 if (&quot;OPTIONS&quot;.equals(request.getMethod().toUpperCase())) &#123; return true; &#125; // 获取token String token = request.getHeader(&quot;token&quot;); // 如果没有token直接拦截，返回错误信息 if (token == null) &#123; // 这里直接用的jackson ObjectMapper mapper = new ObjectMapper(); String result = mapper.writeValueAsString(new ResponseResult(ResponseResult.UNAUTHORIZED, &quot;登录失效&quot;)); response.getWriter().print(result); return false; &#125; try &#123; Claims claims = JwtUtil.parseJWT(token); &#125; catch (Exception e) &#123; // token解析失败 e.printStackTrace(); // token不合法 拦截，返回错误信息 ObjectMapper mapper = new ObjectMapper(); String result = mapper.writeValueAsString(new ResponseResult(ResponseResult.UNAUTHORIZED, &quot;登录失效&quot;)); response.getWriter().print(result); return false; &#125; return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 5. 前端页面跳转处理 前端在跳转页面前，应当也要校验登录状态信息 这里用vue router的全局路由守卫示例 1234567891011121314151617181920212223242526// 全局路由导航守卫router.beforeEach((to, from) =&gt; &#123; // console.log(to); // 去哪儿 // console.log(from); // 从哪儿来 if (to.meta.requiresAuth == true) &#123; let token = getToken() if (token == null || token == &quot;&quot;) &#123; message.warning(&quot;登录失效&quot;) router.push(&quot;/admin/login&quot;) return false; &#125; // 校验Token合法性 checkLoginState().then(response =&gt; &#123; let data = response.date if (data.code == 200) &#123; return true &#125; else &#123; message.warning(data.msg) router.push(&quot;/admin/login&quot;) return false; &#125; &#125;) &#125; return true;&#125;); 6. 退出登录 可以看这篇文章：https://blog.csdn.net/a1098766713/article/details/102914354 这里使用最简单的方法 123456logout() &#123; // 无为而治 window.localStorage.removeItem(&quot;token&quot;) window.localStorage.removeItem(&quot;username&quot;) this.$router.push(&quot;/admin/login&quot;); &#125;, 7. 本文关联代码7.1 前端 request.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import axios from &#x27;axios&#x27;import &#123; getToken, message &#125; from &#x27;@/utils&#x27;import router from &#x27;@/router&#x27;const http = axios.create(&#123; baseURL: &#x27;http://localhost:8080&#x27;, // timeout: 4000&#125;)// 配置请求拦截器http.interceptors.request.use( config =&gt; &#123; config.headers = &#123; // 每次请求前带上Token token: getToken() &#125; return config; &#125;, err =&gt; Promise.reject(err));// 配置响应拦截器http.interceptors.response.use(res =&gt; &#123; // console.log(&quot;响应拦截&quot;); // 登录过期 if (res.data.code == 401) &#123; message.error(res.data.msg) router.push(&quot;/admin/login&quot;) &#125; return res;&#125;, err =&gt; &#123; return Promise.reject(err)&#125;);export const get = (url, param) =&gt; &#123; return http.get(url, param)&#125;export const post = (url, param) =&gt; &#123; return http.post(url, param)&#125;export const put = (url, param) =&gt; &#123; return http.put(url, param)&#125;export const del = (url, param) =&gt; &#123; return http.delete(url, param)&#125; api.js 12345678import axios from &#x27;axios&#x27;import &#123; post,get,put,del &#125; from &#x27;./request&#x27;// 后台管理登录export const login = param =&gt; post(&quot;/admin/login&quot;,param)// 校验登录状态export const checkLoginState = () =&gt; get(&quot;/admin/checkLoginState&quot;) utils.js 12345678910111213141516171819202122232425import &#123; ElMessage &#125; from &quot;element-plus&quot;;export const message = &#123; error: msg =&gt; &#123; ElMessage(&#123; showClose: true, message: msg, type: &quot;error&quot;, &#125;); &#125;, success: msg =&gt; &#123; ElMessage(&#123; showClose: true, message: msg, type: &quot;success&quot;, &#125;); &#125;, warning: msg =&gt; &#123; ElMessage(&#123; showClose: true, message: msg, type: &quot;warning&quot;, &#125;); &#125;&#125; 7.2 后端 ResponseResult.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class ResponseResult &#123; /** * 表明该请求被成功地完成，所请求的资源发送到客户端 */ public static final Integer OK = 200; /** * 请求要求身份验证，常见对于需要登录而用户未登录的情况。 */ public static final Integer UNAUTHORIZED = 401; /** * 服务器拒绝请求，常见于机密信息或复制其它登录用户链接访问服务器的情况。 */ public static final Integer FORBIDDEN = 403; /** * 服务器无法取得所请求的网页，请求资源不存在。 */ public static final Integer NOT_FOUND = 404; /** * 服务器内部错误。 */ public static final Integer SERVER_ERROR = 500; private Integer code; private String msg = &quot;&quot;; private Object data = new int[0]; public ResponseResult() &#123; &#125; public ResponseResult(Integer code) &#123; this.code = code; &#125; public ResponseResult(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125; public ResponseResult(Integer code, Object data) &#123; this.code = code; this.data = data; &#125; public ResponseResult(Integer code, String msg, Object data) &#123; this.code = code; this.msg = msg; this.data = data; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125; @Override public String toString() &#123; return &quot;Result&#123;&quot; + &quot;code=&quot; + code + &quot;, msg=&#x27;&quot; + msg + &#x27;\\&#x27;&#x27; + &quot;, data=&quot; + data + &#x27;&#125;&#x27;; &#125;&#125; JwtUtil.java 依赖于jjwt 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * JWT工具类 */public class JwtUtil &#123; //有效期为 public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000 一个小时 //设置秘钥明文 public static final String JWT_KEY = &quot;shfciksadasfa21435ggdlhvjanv&quot;; public static String getUUID()&#123; return UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @return */ public static String createJWT(String subject) &#123; JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间 return builder.compact(); &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @param ttlMillis token超时时间 * @return */ public static String createJWT(String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间 return builder.compact(); &#125; /** * 创建token * @param id * @param subject * @param ttlMillis * @return */ public static String createJWT(String id, String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间 return builder.compact(); &#125; private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) &#123; SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; SecretKey secretKey = generalKey(); long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); if(ttlMillis==null)&#123; ttlMillis=JwtUtil.JWT_TTL; &#125; long expMillis = nowMillis + ttlMillis; Date expDate = new Date(expMillis); return Jwts.builder() .setId(uuid) //唯一的ID .setSubject(subject) // 主题 可以是JSON数据 .setIssuer(&quot;huanyv&quot;) // 签发者 .setIssuedAt(now) // 签发时间 .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥 .setExpiration(expDate); &#125; /** * 生成加密后的秘钥 secretKey * @return */ public static SecretKey generalKey() &#123; byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;); return key; &#125; /** * 解析 * * @param jwt * @return * @throws Exception */ public static Claims parseJWT(String jwt) throws Exception &#123; SecretKey secretKey = generalKey(); return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(jwt) .getBody(); &#125;&#125; 12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt;&lt;/dependency&gt;"},{"title":"控制台输出彩色文字","path":"/2023/01/07/控制台输出彩色文字/","content":"控制台输出彩色文字1. Java1.1 转义 在IDEA控制台、linux环境下生效，windows的cmd不生效 123public void test05() &#123; System.out.println(&quot;\\033[31;3m微信到账：1亿元\\033[0m&quot;);&#125; 123456789字体颜色： 黄色：33 绿色：32 青色：36 红色：31 黑色：30 蓝色：34 白色：37背景颜色： 黄色：43 绿色：42 青色：46 红色：41 黑色：40 蓝色：44 白色：47字体效果：删除线：9 下划线：4 斜体：3 默认：0 反显：7 或 8 粗体：1温馨提示：Java控制台无法输出背景色！Java彩色字体格式：&quot;\\033[你的字体颜色;字体效果m你的字符（输出的字符）\\033[0m&quot; 1.2 jansi12345&lt;dependency&gt; &lt;groupId&gt;org.fusesource.jansi&lt;/groupId&gt; &lt;artifactId&gt;jansi&lt;/artifactId&gt; &lt;version&gt;2.4.0&lt;/version&gt;&lt;/dependency&gt; 在windows和linux环境生效，在idea不生效 不执行AnsiConsole.systemInstall();将在idea生效，但在windows不生效 123456public void test05() &#123; AnsiConsole.systemInstall(); Ansi content = ansi().eraseScreen().fg(Ansi.Color.GREEN).a(&quot;Hello&quot;).reset(); System.out.println(content); AnsiConsole.systemUninstall();&#125; 加入判断 1234567891011121314151617181920public void test05() &#123; boolean runInIDEA = CheckRunInIDEA(); if (!runInIDEA) &#123; AnsiConsole.systemInstall(); &#125; Ansi content = ansi().eraseScreen().fg(Ansi.Color.GREEN).a(&quot;Hello&quot;).reset(); System.out.println(content); if (!runInIDEA) &#123; AnsiConsole.systemUninstall(); &#125;&#125;private static boolean CheckRunInIDEA() &#123; try &#123; Class.forName(&quot;com.intellij.rt.execution.application.AppMainV2&quot;); return true; &#125; catch (ClassNotFoundException ignored) &#123; return false; &#125;&#125; 2. C 上面的转义在C语言同样生效，同样的在windows的cmd不生效 用windows.h https://baike.baidu.com/item/SetConsoleTextAttribute/570121?fr=aladdin https://baike.baidu.com/item/GetStdHandle/6909878?fr=aladdin https://www.jb51.net/article/207562.htm 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;int PrintColorText(const char *Text, WORD Attributes) &#123; int\tnRet = 0; //注意：GetStdHandle()返回的不是一个duplicate handle，而是真正的输出缓冲区的句柄！ //所以不要试图关闭它，否则就再也不能向缓冲区输出任何东西了。 HANDLE\thOut = GetStdHandle(STD_OUTPUT_HANDLE); if (hOut != INVALID_HANDLE_VALUE)\t&#123; if (SetConsoleTextAttribute(hOut, Attributes)) &#123; nRet = printf(Text); &#125; //恢复白色文字，黑色背景 SetConsoleTextAttribute(hOut, FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED); &#125; return nRet;&#125;int main()&#123; // 黄色文字，无背景 PrintColorText(&quot;Hello, world. &quot;, FOREGROUND_RED | FOREGROUND_GREEN); printf(&quot;Hello, world. &quot;); return 0;&#125;"},{"title":"如何进行参数校验","path":"/2023/01/06/后端如何进行参数校验/","content":"如何进行参数校验[TOC] 1. 不好的参数校验 对于用户输入的数据来说，不只前端要校验数据，后端也要对数进行校验，比如入参是否可以为空、入参长度是否满足你的期望长度 比如你的数据库长度设置的varchar(16)，对方直接来了个36的，那么数据库直接异常 如果以if判断来进行参数校验，代码就会非常的难看 123456789101112131415161718@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @PostMapping(&quot;/add&quot;) public ResponseEntity&lt;String&gt; add(User user) &#123; if(user.getName()==null) &#123; return ResponseResult.fail(&quot;用户名不可为空！&quot;); &#125; else if(user.getName().length()&lt;5 || user.getName().length()&gt;15)&#123; return ResponseResult.fail(&quot;用户名长度在 5-15 之间&quot;); &#125; if(user.getAge()&lt; 1 || user.getAge()&gt; 150) &#123; return ResponseResult.fail(&quot;你敢是乌龟吗？&quot;); &#125; // 参数合法 return ResponseEntity.ok(&quot;success&quot;); &#125;&#125; 针对这个问题，Java开者在Java API规范 (JSR303) 定义了Bean校验的标准validation-api，但没有提供实现。 hibernate validation是对这个规范的实现，并增加了校验注解如@Email、@Length等。 Spring Validation是对hibernate validation的二次封装，用于支持spring mvc参数自动校验。 2. 开始 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 对bean的属性添加校验注解 可以单独使用一个DTO 每个注解指定message属性，为错误信息提示 有哪些常用的校验?(在下面) 1234567891011121314151617181920@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123; private Long id; @NotBlank private String username; @NotBlank private String password; private String sex; @Email private String email; @Pattern(regexp = &quot;^[0-9]&#123;11&#125;$&quot;, message = &quot;手机号格式不正确&quot;) private String phone;&#125; 在Controller的方法入参上使用@Valid注解，参数校验的值放在BindingResult中 12345678910111213141516171819@Slf4j@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @PostMapping public ResponseResult addUser(@Valid User user, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; // 数据格式出现错误 Map&lt;String, String&gt; map = bindingResult.getFieldErrors().stream() .collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage)); return new ResponseResult(ResponseStatus.FAIL.getCode(), &quot;数据格式校验失败&quot;, map) ; &#125; log.info(&quot;用户信息：&#123;&#125;&quot;,user); return ResponseResult.success(&quot;添加成功！&quot;); &#125;&#125; 3. 统一异常处理 在数据校验失败时会发出BindException异常，可以使用spring的统一异常处理器进行处理 1234567891011@Slf4j@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @PostMapping public ResponseResult addUser(@Valid User user) &#123; log.info(&quot;用户信息：&#123;&#125;&quot;,user); return ResponseResult.success(&quot;添加成功！&quot;); &#125;&#125; 123456789101112@RestControllerAdvicepublic class CustomExceptionHandler &#123; @ExceptionHandler(BindException.class) public ResponseResult validationException(BindException e) &#123; Map&lt;String, String&gt; map = e.getBindingResult().getFieldErrors().stream() .collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage)); return new ResponseResult(ResponseStatus.FAIL.getCode(), &quot;数据格式校验失败&quot;, map) ; &#125;&#125; 4. 分组校验 我们一般在数据增删改查时，通常增加时使用数据库的主键自增，也就是增加时主键必须为null，删改查时主键必须不为null 这里同一bean中出现了两种校验场景，可以使用分组校验 【分组】即为接口，接口中只是作为一个标识，无需任何代码 123456// 添加时的组public interface AddValid &#123;&#125;// 修改时的组public interface UpdateValid &#123;&#125; 设置分组后，校验注解可以指定组 没有设置groups属性的注解，使得分组校验时不会校验 123456789101112131415161718192021222324@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123; @Null(groups = &#123;AddValid.class&#125;) @NotNull(groups = &#123;UpdateValid.class&#125;) private Long id; @NotBlank(groups = &#123;AddValid.class, UpdateValid.class&#125;) private String username; @NotBlank(groups = &#123;AddValid.class&#125;)// @NotBlank private String password; private String sex; @Email(groups = &#123;AddValid.class, UpdateValid.class&#125;) private String email; @Pattern(regexp = &quot;^[0-9]&#123;11&#125;$&quot;, message = &quot;手机号格式不正确&quot;, groups = &#123;AddValid.class, UpdateValid.class&#125;) private String phone;&#125; 使用分组校验，形参使用@Validated注解，value属性指定组 12345678910111213141516171819202122@Slf4j@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @PostMapping public ResponseResult addUser(@Validated(&#123;AddValid.class&#125;) User user) &#123; log.info(&quot;用户信息：&#123;&#125;&quot;,user); return ResponseResult.success(&quot;添加成功！&quot;); &#125; @PutMapping public ResponseResult updateUser(@Validated(UpdateValid.class) User user) &#123; log.info(&quot;用户信息：&#123;&#125;&quot;,user); return ResponseResult.success(&quot;修改成功&quot;); &#125;&#125; 5. 常用的校验注解 JSR303规范 12345678910111213141516171819202122@AssertFalse 被注释的元素只能为false@AssertTrue 被注释的元素只能为true@DecimalMax 被注释的元素必须小于或等于&#123;value&#125;@DecimalMin 被注释的元素必须大于或等于&#123;value&#125;@Digits 被注释的元素数字的值超出了允许范围(只允许在&#123;integer&#125;位整数和&#123;fraction&#125;位小数范围内)@Email 被注释的元素不是一个合法的电子邮件地址@Future 被注释的元素需要是一个将来的时间@FutureOrPresent 被注释的元素需要是一个将来或现在的时间@Max 被注释的元素最大不能超过&#123;value&#125;@Min 被注释的元素最小不能小于&#123;value&#125;@Negative 被注释的元素必须是负数@NegativeOrZero 被注释的元素必须是负数或零@NotBlank 被注释的元素不能为空、空白字符串@NotEmpty 被注释的元素不能为空@NotNull 被注释的元素不能为null@Null 被注释的元素必须为null@Past 被注释的元素需要是一个过去的时间@PastOrPresent 被注释的元素需要是一个过去或现在的时间@Pattern 被注释的元素需要匹配正则表达式&quot;&#123;regexp&#125;&quot;@Positive 被注释的元素必须是正数@PositiveOrZero 被注释的元素必须是正数或零@Size 被注释的元素个数必须在&#123;min&#125;和&#123;max&#125;之间 hibernate validation是对这个规范的实现，并增加了一些其他校验注解，如@Email，@Length，@Range等等 12345678910111213141516171819@CreditCardNumber 被注释的元素不合法的信用卡号码@Currency 被注释的元素不合法的货币 (必须是&#123;value&#125;其中之一)@EAN 被注释的元素不合法的&#123;type&#125;条形码@Email 被注释的元素不是一个合法的电子邮件地址 (已过期)@Length 被注释的元素长度需要在&#123;min&#125;和&#123;max&#125;之间@CodePointLength 被注释的元素长度需要在&#123;min&#125;和&#123;max&#125;之间@LuhnCheck 被注释的元素$&#123;validatedValue&#125;的校验码不合法, Luhn模10校验和不匹配@Mod10Check 被注释的元素$&#123;validatedValue&#125;的校验码不合法, 模10校验和不匹配@Mod11Check 被注释的元素$&#123;validatedValue&#125;的校验码不合法, 模11校验和不匹配@ModCheck 被注释的元素$&#123;validatedValue&#125;的校验码不合法, $&#123;modType&#125;校验和不匹配 (已过期)@NotBlank 被注释的元素不能为空 (已过期)@NotEmpty 被注释的元素不能为空 (已过期)@ParametersScriptAssert 被注释的元素执行脚本表达式&quot;&#123;script&#125;&quot;没有返回期望结果@Range 被注释的元素需要在&#123;min&#125;和&#123;max&#125;之间@SafeHtml 被注释的元素可能有不安全的HTML内容@ScriptAssert 被注释的元素执行脚本表达式&quot;&#123;script&#125;&quot;没有返回期望结果@URL 被注释的元素需要是一个合法的URL@DurationMax 被注释的元素必须小于$&#123;inclusive == true ? &#x27;或等于&#x27; : &#x27;&#x27;&#125;$&#123;days == 0 ? &#x27;&#x27; : days += &#x27;天&#x27;&#125;$&#123;hours == 0 ? &#x27;&#x27; : hours += &#x27;小时&#x27;&#125;$&#123;minutes == 0 ? &#x27;&#x27; : minutes += &#x27;分钟&#x27;&#125;$&#123;seconds == 0 ? &#x27;&#x27; : seconds += &#x27;秒&#x27;&#125;$&#123;millis == 0 ? &#x27;&#x27; : millis += &#x27;毫秒&#x27;&#125;$&#123;nanos == 0 ? &#x27;&#x27; : nanos += &#x27;纳秒&#x27;&#125;@DurationMin 被注释的元素必须大于$&#123;inclusive == true ? &#x27;或等于&#x27; : &#x27;&#x27;&#125;$&#123;days == 0 ? &#x27;&#x27; : days += &#x27;天&#x27;&#125;$&#123;hours == 0 ? &#x27;&#x27; : hours += &#x27;小时&#x27;&#125;$&#123;minutes == 0 ? &#x27;&#x27; : minutes += &#x27;分钟&#x27;&#125;$&#123;seconds == 0 ? &#x27;&#x27; : seconds += &#x27;秒&#x27;&#125;$&#123;millis == 0 ? &#x27;&#x27; : millis += &#x27;毫秒&#x27;&#125;$&#123;nanos == 0 ? &#x27;&#x27; : nanos += &#x27;纳秒&#x27;&#125; 6. 自定义validation 定义注解 123456789@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)@Retention(RUNTIME)@Documented@Constraint(validatedBy = &#123;TelephoneNumberValidator.class&#125;) // 指定校验器public @interface TelephoneNumber &#123; String message() default &quot;Invalid telephone number&quot;; Class&lt;?&gt;[] groups() default &#123; &#125;; Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;;&#125; 定义校验器 123456789101112public class TelephoneNumberValidator implements ConstraintValidator&lt;TelephoneNumber, String&gt; &#123; private static final String REGEX_TEL = &quot;0\\\\d&#123;2,3&#125;[-]?\\\\d&#123;7,8&#125;|0\\\\d&#123;2,3&#125;\\\\s?\\\\d&#123;7,8&#125;|13[0-9]\\\\d&#123;8&#125;|15[1089]\\\\d&#123;8&#125;&quot;; @Override public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) &#123; try &#123; return Pattern.matches(REGEX_TEL, s); &#125; catch (Exception e) &#123; return false; &#125; &#125;&#125; 使用 1234567891011121314@Data@Builder@ApiModel(value = &quot;User&quot;, subTypes = &#123;AddressParam.class&#125;)public class UserParam implements Serializable &#123; private static final long serialVersionUID = 1L; @NotEmpty(message = &quot;&#123;user.msg.userId.notEmpty&#125;&quot;, groups = &#123;EditValidationGroup.class&#125;) private String userId; @TelephoneNumber(message = &quot;invalid telephone number&quot;) // 这里 private String telephone;&#125;"}]